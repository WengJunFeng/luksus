#### FUNCTIONS ######

# SHOW LOGO, BUT DO IT OPTIMALLY BY DETERMINING TERMINAL SIZE
DISPLAYLOGO()
{
if [ $width -gt 119 ] 
then
  tail -n 12 LUKSUS.logo
  else
  head -n 6 LUKSUS.logo
fi
}

LOOPBACKMETHOD()
{
  if [[ $device = *loop* ]]
  then
    echo Running Linux
    echo Okay we are using $device ... Beginning loopbackmethod
    head -c $luksfilesize /dev/zero > $luksfile
    losetup $device $luksfile
  elif [[ $device = *vn* ]]
    then
    echo DragonFlyBSD - Nice...
    echo Okay we are using $device ... Beginning loopbackmethod
    ghead -c $luksfilesize /dev/zero > $luksfile
    # vnconfig needs to run once first, it seems that the kernel
    # is initializing something on first run
    vnconfig 1>/dev/null 2>/dev/null
    vnconfig $device $luksfile
  else
    echo "Okay, not using a loopback device, proceeding in normal mode"
  fi

}  


DONTSHREDIFLOOPBACK()
{
  if [[ $device != *loop* ]]
  then
    echo Okay we are using $device ... Which is not a loopback device
    echo Shredding ...
    # shred
    # Totally infuse the drive with random data
    # Good for paranoid and security minded people
    # This takes about 5 hours on a 3TB drive
    shred -f -v -n1 $device
  elif [[ $device != *vn* ]]
  then
    echo On DragonFlyBSD
    echo in the middle of the shredding.place
    gshred -f -v -n1 $device
  else 
    echo "Okay, $device is a loopback device, not shredding."
  fi
}  

ASKUSERVERIFY()
{
dialog --title "WELCOME TO $programname" \
--msgbox "\n 
\n
VERSION: $version\n
DATE   : $date \n
 \n
" 50 50

echo ################################################
echo DRIVE ENCRYPTION
echo THIS SCRIPT ASSUMES YOU WANT TO COMPLETELY ERASE
echo THE DEVICE YOU HAVE SPECIFIED
echo ################################################

dialog --title "DRIVE ENCRYPTION SCRIPT" \
--msgbox "\n DETAILS AS SUBMITTED BY THE USER
\n \n \n
NAME: 	        $name \n
DRIVE:         $device \n
MOUNTPOINT:    $mountpoint \n
KEYFILE:       $keyfile \n
HEADER BACKUP: $headerfile\n
FILECONTAINER LOCATION: $luksfile\n
FILECONTAINER SIZE: $luksfilesize\n
USING TRUECRYPT: $USETRUECRYPT\n
" 50 50


echo ################################################
echo DETAILS AS SUBMITTED BY THE USER
echo PLEASE VERIFY THAT THESE ARE CORRECT
echo DRIVE: $device
echo NAME: $name
echo KEYFILE: $keyfile
echo MOUNTPOINT: $mountpoint
echo HEADER BACKUP: $headerfile
echo ################################################
echo UNDERSTAND THAT YOU WILL NUKE YOUR DRIVE: $device
echo HIT CTRL+C NOW TO QUIT, OR HIT ANY KEY TO CONTINUE
read || exit
}


THESECRETSAUCE()
{
# mkdir
# create mountpoint & keydirectory
# i should create an if routine here
# works for now
mkdir -p $mountpoint
mkdir -p $keydir

# dd
# generate a keyfile using completely random data
# from /dev/urandom
dd if=/dev/urandom of=$keyfile bs=512 count=256

# Begin the encryption - with TrueCrypt or LUKS
if [[ $USETRUECRYPT = true ]];
then
echo TrueCrypt mode
tcplay --create --device=$device --cipher=AES-256-XTS --keyfile=$keyfile --map=$name
else
# cryptsetup
# format the drive using encryption
# create an encrypted drive with aes-xts-plain cipher
# key size 512
# remember that the key size will increase the safety of the
# encryption, but the a stronger keyfile with more entropy (randomness)
# will produce the best security. 
echo Cryptsetup mode
cryptsetup --batch-mode --verbose --key-size=512 --cipher=aes-xts-plain64 luksFormat $device $keyfile
fi



# cryptsetup isLuks
# check to see if the device has got a valid LUKS container
# if it does not, then exit
#if cryptsetup isLuks /dev/sda1 &> /dev/null  # Suppress output.
if cryptsetup isLuks $device  # Provides output
then
echo "Checking to see if the device contains a LUKS volume"
echo "The device positively contains a LUKS volume."
echo "Great!"
echo "Continuing"
else echo "The device does not contain a LUKS volume"
echo "Something went wrong and the LUKS device has not been created"
echo "Exiting"
exit 1
fi


# cryptsetup luksOpen
# mount the encrypted drive using a keyfile
cryptsetup luksOpen $device $name --key-file=$keyfile

# cryptsetup luksHeaderBackup
# backup the header of the luks container
# as strongly recommended by the luks FAQ
# if it does not, then exit
echo "Taking a backup of the LUKS container header"
if cryptsetup luksHeaderBackup --header-backup-file=$headerfile $device --verbose
then
echo "The LUKS container header has been backed up successfully"
echo "Great!"
echo "Continuing LUKSUS"
else echo "CATASTROPHIC FAILURE: Could not backup LUKS container header"
echo "Something went wrong and LUKSUS failed to backup the LUKS header"
echo "Exiting"
exit 1
fi
}


CREATEANDMOUNTFS()
{
if [ $UNAME = DragonFly ] ;
then
echo DragonFlyBSD mode
# ON DRAGONFLY, WE MUST USE THE UFS FILESYSTEM INSTEAD
newfs /dev/mapper/$name
# mounting
mount /dev/mapper/$name /mnt/$name
else
# mkfs.ext4 - create a filesystem on top of the encrypted drive
mkfs.ext4 /dev/mapper/$name
if [ $? -ne 0 ] ; then
    mkfs.ext4 -F $device
    fi
# mounting the newly created drive
mount -t ext4 /dev/mapper/$name $mountpoint > /dev/null 2>&1
if [ $? -ne 0 ] ; then
    mount -t ext4 $device $mountpoint > /dev/null 2>&1
    fi
fi

}

DISPLAYSUMMARY()
{
echo ################################################
echo Results of LUKSUS:
echo DRIVE: $device
echo NAME: $name
echo KEYFILE: $keyfile
echo MOUNTPOINT: $mountpoint
echo HEADER BACKUP: $headerfile
echo CONTAINER $luksfile $luksfilesize MB
echo Currently mounted at: `mount | grep $name`
echo `df -h | head -n 1`
echo `df -h | grep $name`
echo ################################################
time2="$(date +%s.%N)"
# This time taken needs attention - does not work anymore
# for some reason
# echo "Time taken: 0$(echo $time2-$time1 | bc) seconds"
ls -l $device
ls -l $luksfile
ls -l /keys/$name*
}
