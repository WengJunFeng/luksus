#### FUNCTIONS ######

# SHOW LOGO, BUT DO IT OPTIMALLY BY DETERMINING TERMINAL SIZE
DISPLAYLOGO()
{
if [ $width -gt 119 ] 
then
  gtail -n 12 LUKSUS.logo
  else
  ghead -n 6 LUKSUS.logo
fi
}

OSTEST()
{
# OS Checking
  if [[ $UNAME == Linux ]]
  then
  ENCRYPTION=LUKS
  echo On $UNAME, defaulting to $ENCRYPTION
  elif [[ $UNAME == Dragonfly ]]
  then
  ENCRYPTION=LUKS
  echo On $UNAME, defaulting to $ENCRYPTION
  elif [[ $UNAME = FreeBSD ]]
  then
  ENCRYPTION=GELI
  echo On $UNAME, Encryption set to $ENCRYPTION
  else
  ENCRYPTION=LUKSUS
  echo No idea $UNAME, defaulting to $ENCRYPTION
  fi
}

LOOPBACKTEST()
{
  if [[ $device == *loop* ]]
  then
  loopbackdevice=true
  elif [[ $device == *vn* ]]
  then
  loopbackdevice=true
  elif [[ $device = *md* ]]
  then
  loopbackdevice=true
  else
  loopbackdevice=false  
  fi
}

DRAGONFLYHOUSEKEEPING()
{
if [ $UNAME == DragonFly ] ;
	then 
	echo We are on DragonFlyBSD here. 
	# crude way to deal with different binary names
	alias head=ghead
        alias shred=gshred
# loading dm kernel module in DragonflyBSD
	kldload dm
	# for some reason vnconfig must be ran once before it will start working
	# it seems that the DragonFlyBSD kernel is initializing something
	# so that's exactly what I'm doing here
	vnconfig 1>/dev/null 2>/dev/null
	else
	echo ""
fi
}

FREEBSDHOUSEKEEPING()
{
if [ $UNAME == FreeBSD ] ;
	then 
	echo We are on FreeBSD here. Cool.
	# crude way to deal with different binary names
	alias head=ghead
        alias shred=gshred
	alias head ghead
	alias shred gshred
# loading dm kernel module in FreeBSD
	kldload geom_eli
        else 
	echo ""
fi
}

DEVICEEXISTS()
{
# Check to see if specified device exists
if [ -e "$device" ]
	then 
	echo "OK, $device exists"
	else 
	echo "$device was not found. $programname is now exiting" 
	exit 1
fi
}

LOOPBACKMETHOD()
{
  if [[ $loopbackdevice = true ]] && [[ $UNAME = Linux ]]
  then
    echo Beginning loopbackmethod on $device
    head -c $luksfilesize /dev/zero > $luksfile
    # block device housekeeping
    losetup -f 1>/dev/null 2>/dev/null
    losetup $device $luksfile
  elif [[ $loopbackdevice = true ]] && [[ $UNAME = DragonFly ]]
    then
    echo DragonFlyBSD - Nice...
    echo Beginning loopbackmethod on $device
    ghead -c $luksfilesize /dev/zero > $luksfile
    # block device housekeeping
    # vnconfig needs to run once first, it seems that the kernel
    # is initializing something on first run. Then it must run again.
    vnconfig 1>/dev/null 2>/dev/null
    vnconfig $device $luksfile
   elif [[ $loopbackdevice = true ]] && [[ $UNAME = FreeBSD ]]
   then
   echo FreeBSD - Nice...
   ghead /dev/zero -c $luksfilesize > $luksfile
#  vanilla, but needs the devicenumber also #  mdconfig -a -t vnode -f $luksfile
   mdconfig -a -t vnode -f $luksfile -u $freebsdloopnumber
  else
    echo "Okay, not using a loopback device, proceeding in normal mode"
  fi
}  

DONTSHREDIFLOOPBACK()
{
  if [[ $device != *loop* ]] && [[ $device != *vn* ]] && [[ $device != *md* ]]
  then
    echo "Okay we are using $device ..."
    echo Shredding ...
    # shred
    # Totally infuse the drive with random data
    # Good for paranoid and security minded people
    # This takes about 5 hours on a 3TB drive
    shred -f -v -n1 $device
  elif [[ $device = !*vn* ]]
  then
    echo On DragonFlyBSD. Okay cool.
    echo in the middle of the shredding.place
    gshred -f -v -n1 $device
    elif [[ $device != *md* ]]
  then
    echo On FreeBSD. Okay cool.
    echo in the middle of the shredding.place
    gshred -f -v -n1 $device
  else
echo "$device is a loopback device"
  fi
}  


ASKUSERVERIFYDIALOG()
{
if [[ $dialog == true ]];
then
dialog --title "WELCOME TO $programname" \
--msgbox "\n$programname $version $date on $UNAME\n\n
Written by \n
$author \n
" 10 30

echo ################################################
echo DRIVE ENCRYPTION
echo THIS SCRIPT ASSUMES YOU WANT TO COMPLETELY ERASE
echo THE DEVICE YOU HAVE SPECIFIED
echo ################################################

dialog --title "DRIVE ENCRYPTION SCRIPT" \
--yesno "\nDETAILS AS SUBMITTED BY THE USER
\n \n \n
ENCRYPTION USED: $ENCRYPTION
\n
NAME: 	        $name \n
DRIVE:         $device \n
MOUNTPOINT:    $mountpoint \n
KEYFILE:       $keyfile \n
HEADER BACKUP: $headerfile\n
FILECONTAINER LOCATION: $luksfile\n
FILECONTAINER SIZE: $luksfilesize\n
ENCRYPTION USED: $ENCRYPTION\n
USING KEYFILE: $USEKEY\n
LOOPBACKDEVICE: $loopbackdevice\n
OS: $UNAME\n
\n\n\n
ARE THESE VALUES CORRECT? \n\nIF UNSURE SAY NO.
" 30 50

case $? in
0)
    ;;
1)
  echo "You have pressed NO. LUKSUS will now close."  
  exit 1;;
255)
  echo "Box closed"   ;;
esac
else
echo ""
fi
}

ASKUSERVERIFYCONSOLE()
{
echo ################################################
echo DETAILS AS SUBMITTED BY THE USER
echo PLEASE VERIFY THAT THESE ARE CORRECT
echo ENCRYPTION USED: $ENCRYPTION
echo DRIVE: $device
echo NAME: $name
echo MOUNTPOINT: $mountpoint
echo HEADER BACKUP: $headerfile
echo USING KEYFILE: $USEKEY
echo KEYFILE: $keyfile
echo LOOPBACK: $loopbackdevice
echo OS: $UNAME
echo ################################################
echo JUST TO MAKE DOUBLY SURE THAT YOU ARE FORMATTING THE CORRECT DRIVE
echo WE ASK AGAIN. IS THIS THE CORRECT DEVICE TO FORMAT AND ENCRYPT?
echo YOU WILL NUKE YOUR DRIVE: $device
echo HIT CTRL+C NOW TO QUIT, OR HIT ANY KEY TO CONTINUE
echo ""
echo SERIOUSLY - LAST CHANCE
read || exit
}

CREATEKEYFILE()
{
if [[ $USEKEY == true ]];
then
echo Creating key
# generate a keyfile using completely random data
dd if=/dev/urandom of=$keyfile bs=512 count=256
else 
echo ...
fi
}

TRUECRYPT()
{
# Begin the encryption - with TrueCrypt?
if [[ $ENCRYPTION == TRUECRYPT ]] && [[ $USEKEY == false ]];
then
echo TrueCrypt mode
tcplay --create --device=$device --cipher=AES-256-XTS
else
echo ""
fi
}

TRUECRYPTKEYFILE()
{
# Begin the encryption - with TrueCrypt and with key?
if [[ $ENCRYPTION == TRUECRYPT ]] && [[ $USEKEY == true ]];
then
echo TrueCrypt mode and adding a keyfile
# had to remove --map=$name
tcplay --create --device=$device --cipher=AES-256-XTS --keyfile=$keyfile
else
echo ""
fi
}

TRUECRYPTOPEN()
{
if [[ $ENCRYPTION == TRUECRYPT ]] && [[ $USEKEY == false ]];
then
# tcplay mount
# mount the encrypted drive using a keyfile
echo Attempting to open and mount the newly created Truecrypt encrypted volume
tcplay -m $name -d $device
elif [[ $ENCRYPTION == TRUECRYPT ]] && [[ $USEKEY == true ]];
then
echo Attempting to open newly created Truecrypt volume $name
tcplay -m $name -d $device -k $keyfile
else 
echo ""
fi
}


LUKS()
{
if [[ $ENCRYPTION == LUKS ]] && [[ $USEKEY == false ]];
then
echo LUKS with passphrase
echo You will only be prompted for a password once. Type carefully.
cryptsetup --batch-mode --verbose --cipher=aes-xts-plain64 luksFormat $device
else
echo ""
fi
}

LUKSKEYFILE()
{
# Begin the encryption - with LUKS and with a keyfile?
if [[ $ENCRYPTION == LUKS ]] && [[ $USEKEY = true ]];
then
# cryptsetup
# format the drive using encryption
# create an encrypted drive with aes-xts-plain cipher
# key size 512
# remember that the key size will increase the safety of the
# encryption, but the a stronger keyfile with more entropy (randomness)
# will produce the best security. 
echo LUKS mode
cryptsetup --batch-mode --verbose --key-size=512 --cipher=aes-xts-plain64 luksFormat $device $keyfile
else
echo ""
fi
}


LUKSVERIFY()
{
if [[ $ENCRYPTION = LUKS ]];
then
# cryptsetup isLuks
# check to see if the device has got a valid LUKS container
# if it does not, then exit
echo "Verifying LUKS volume"
cryptsetup isLuks $device  || "echo "The device does not contain a LUKS volume. This is a problem since it should have a LUKS volume by now. Please check commandline arguments and try again" && exit 1"
echo "The device positively contains a LUKS volume."
echo "Great!"
# cryptsetup luksHeaderBackup
# backup the header of the luks container
# as strongly recommended by the luks FAQ
# if it does not, then exit
echo "Taking a backup of the LUKS container header"
cryptsetup luksHeaderBackup --header-backup-file=$headerfile $device --verbose || "echo Something went wrong and LUKSUS failed to backup the LUKS header. Please check commandline arguments and try again. && exit 1"
echo "The LUKS container header has been backed up successfully"
echo "Great!"
else 
echo ""
fi
}

LUKSOPEN()
{
if [[ $ENCRYPTION == LUKS ]] && [[ $USEKEY == true ]];
then
# cryptsetup luksOpen
# mount the encrypted drive using a keyfile
echo Attempting to open the newly created $ENCRYPTION volume $name with $keyfile
cryptsetup luksOpen $device $name --key-file=$keyfile
elif [[ $ENCRYPTION == LUKS ]] && [[ $USEKEY == false ]];
then
echo Attempting to open the newly created $ENCRYPTION volume $name
cryptsetup luksOpen $device $name
else 
echo ""
fi
}

GELI()
{
if [[ $ENCRYPTION == GELI ]] && [[ $USEKEY == false ]]
then
# geli create
echo Initializing $device with $ENCRYPTION
geli init -s 4096 $device
cp /var/backups/md$freebsdloopnumber.eli $keydir/$name.headerbackup
else
echo ""
fi
}

GELIKEYFILE()
{
if [[ ENCRYPTION == GELI ]] && [[ $USEKEY == true ]]
then
echo Initializing $device with $ENCRYPTION with a keyfile
geli init -s 4096 -K $keyfile $device
else
echo ""
fi
}

GELIOPEN()
{
if [[ $ENCRYPTION == GELI ]] && [[ $USEKEY == true ]];
then
# geli attach
# mount the encrypted drive using a keyfile
echo Attempting to open the newly created $ENCRYPTION volume $name with $keyfile
geli attach -k $keyfile $device
elif [[ $ENCRYPTION == GELI ]] && [[ $USEKEY == false ]];
then
echo Attempting to open the newly created $ENCRYPTION volume $name
geli attach $device
else 
echo ""
fi
}

CREATEANDMOUNTFS()
{
mkdir -p $mountpoint
mkdir -p $keydir
if [[ $UNAME == DragonFly ]] ;
then
echo DragonFlyBSD mode
# ON DRAGONFLY, WE MUST USE THE UFS FILESYSTEM INSTEAD
newfs /dev/mapper/$name
# mounting
mount /dev/mapper/$name /mnt/$name
elif [[ $UNAME == FreeBSD ]]
then
newfs $device.eli
mount $device.eli /mnt/$name
elif [[ $UNAME == Linux ]]
then
# mkfs.ext4 - create a filesystem on top of the encrypted drive
mkfs.ext4 /dev/mapper/$name
# mounting the newly created drive
mount -t ext4 /dev/mapper/$name $mountpoint > /dev/null 2>&1
else
echo No Idea What To Do
fi
}

DISPLAYSUMMARY()
{
echo ################################################
date
echo Results of LUKSUS:
echo DRIVE: $device
echo NAME: $name
echo USED KEYFILE: $USEKEY
echo KEYFILE: $keyfile
echo MOUNTPOINT: $mountpoint
echo HEADER BACKUP: $headerfile
echo ENCRYPTION USED: $ENCRYPTION
echo CONTAINER $luksfile $luksfilesize
echo MOUNTPOINT: `mount | grep $name`
echo `df -h | head -n 1`
echo `df -h | grep $name`
echo ################################################
time2="$(date +%s.%N)"
# This time taken needs attention - does not work anymore
# for some reason
# echo "Time taken: 0$(echo $time2-$time1 | bc) seconds"
ls -l $device
#ls -l $luksfile
}

WRITEINFORMATIONFILE()
{
DISPLAYLOGO 1>$keydir/$name.information 2>$keydir/$name.information
DISPLAYSUMMARY 1>>$keydir/$name.information 2>>$keydir/$name.information
ls -l $keydir/$name* 1>>$keydir/$name.information 2>>$keydir/$name.information
}
